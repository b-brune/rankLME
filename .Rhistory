final_scores <- a(order(y - yhat))
final_scores
final_scores %>% plot
plot(final_scores)
plot(sort(final_scores))
set.seed(99099)
d <- raw_data(400, 4, 2, 20, 20)
r <- ranklme(d$X, d$y, d$Z, d$g)
# tests for ranklme function
library(rankLME)
set.seed(99099)
d <- raw_data(400, 4, 2, 20, 20)
r <- ranklme(d$X, d$y, d$Z, d$g)
r
r2 <- ranklme(d$X, d$y, d$Z, d$g, weighted = TRUE)
r
r2
set.seed(1213)
new_order <- sample(1:400)
d_perm <- lapply(d[c(1:3, 5)], function(x) {
if (is.matrix(x)) x[new_order, , drop=FALSE] else x[new_order]
})
r3 <- ranklme(d_perm$X, d_perm$y, d_perm$Z, d_perm$g)
r3
r
r$diagnostics
r3$diagnostics
r$diagnostics[261, ]
r3$diagnostics[1, ]
r3$diagnostics[r3$diagnostics$group == 14, ]
r3$diagnostics[r3$diagnostics$g == 14, ]
r$diagnostics[r3$diagnostics$g == 14, ]
r$diagnostics[r$diagnostics$g == 14, ]
rank(d$y)
rank(d_perm$y)
order(d_perm$y)
order(d$y)
d$y[order(d$y)]
d$y[order(d$y)] == d_perm$y[order(d_perm$y)]
d$y[order(d$g)]
d$y[order(d$g)] %>% plot
library(magrittr)
d$y[order(d$g)] %>% plot
r3 <- ranklme(d_perm$X, d_perm$y, d_perm$Z, d_perm$g)
# tests for ranklme function
library(rankLME)
devtools::install()
install.packages("lme4")
# tests for ranklme function
library(rankLME)
set.seed(99099)
d <- raw_data(400, 4, 2, 20, 20)
r <- ranklme(d$X, d$y, d$Z, d$g)
r$beta
r2 <- ranklme(d$X, d$y, d$Z, d$g, weighted = TRUE)
r2$beta
set.seed(1213)
new_order <- sample(1:400)
d_perm <- lapply(d[c(1:3, 5)], function(x) {
if (is.matrix(x)) x[new_order, , drop=FALSE] else x[new_order]
})
r3 <- ranklme(d_perm$X, d_perm$y, d_perm$Z, d_perm$g)
r3$beta
hodges_lehmann(1.20)
install.packages("robnptests")
robnptests::hodges_lehmann(1:20)
robnptests::hodges_lehmann(sample(1:20))
robnptests::hodges_lehmann(sample(1:50))
# tests for ranklme function
library(rankLME)
set.seed(99099)
d <- raw_data(400, 4, 2, 20, 20)
r <- ranklme(d$X, d$y, d$Z, d$g)
r2 <- ranklme(d$X, d$y, d$Z, d$g, weighted = TRUE)
set.seed(1213)
new_order <- sample(1:400)
d_perm <- lapply(d[c(1:3, 5)], function(x) {
if (is.matrix(x)) x[new_order, , drop=FALSE] else x[new_order]
})
r3 <- ranklme(d_perm$X, d_perm$y, d_perm$Z, d_perm$g)
library(lme4)
install.packages("lme4")
install.packages("lme4")
install.packages("lme4")
set.seed(99099)
d <- raw_data(400, 4, 2, 20, 20)
r <- ranklme(d$X, d$y, d$Z, d$g)
# tests for ranklme function
library(rankLME)
set.seed(99099)
d <- raw_data(400, 4, 2, 20, 20)
r <- ranklme(d$X, d$y, d$Z, d$g)
r2 <- ranklme(d$X, d$y, d$Z, d$g, weighted = TRUE)
set.seed(1213)
new_order <- sample(1:400)
d_perm <- lapply(d[c(1:3, 5)], function(x) {
if (is.matrix(x)) x[new_order, , drop=FALSE] else x[new_order]
})
r3 <- ranklme(d_perm$X, d_perm$y, d_perm$Z, d_perm$g)
library(rfit)
install.packages("rfit")
install.packages("Rfit")
library(Rfit)
help(Rfit)
?rfit
rfit(y ~ X, d)
rfit(y ~ X[, -1], d)
ranklm(d$X, d$y)
ranklm(d$X, d$y)$coef
rfit(y ~ X[, -1], d)
rfit(y ~ X[, -1], d_perm)
ranklm(d_perm$X, d_perm$y)$coef
rfit(y ~ X, d)
rfit(y ~ X[, -1], d)
ranklm(d$X, d$y, mean_function="median")
ranklm(d$X, d$y, mean_function="median")$coef
rfit(y ~ X[, -1], d)
ranklm(d_perm$X, d_perm$y, mean_function="median")$coef
rfit(y ~ X[, -1], d_perm)
new_order <- c(2, 1, 3:400)
d_perm2 <- lapply(d[c(1:3, 5)], function(x) {
if (is.matrix(x)) x[new_order, , drop=FALSE] else x[new_order]
})
r3 <- ranklme(d_perm2$X, d_perm2$y, d_perm2$Z, d_perm2$g)
r4 <- ranklme(d_perm2$X, d_perm2$y, d_perm2$Z, d_perm2$g)
r3 <- ranklme(d_perm$X, d_perm$y, d_perm$Z, d_perm$g)
r3$beta
r4$beta
r$beta
r$beta_init
r3$beta_init
attach(d_perm)
# Sort the variables by group:
ord <- order(g)
ord
y <- y[ord, , drop = FALSE]
Z <- Z[ord, , drop = FALSE]
X <- X[ord, , drop = FALSE]
g_old <- g
g <- g[ord]
# Prepare group matching
n.groups <- length(unique(g))
n.groups
group_sizes <- c(table(g))
group_limits <- cbind(cumsum(group_sizes) - group_sizes + 1, cumsum(group_sizes))
group_sizes
group_limits
g
g[group_limits[1, 1]]
g[group_limits[1, 1]:group_limits[1, 2]]
g[group_limits[2, 1]:group_limits[2, 2]]
d_prem$y[group_limits[2, 1]:group_limits[2, 2]]
d_perm$y[group_limits[2, 1]:group_limits[2, 2]]
d$y[group_limits[2, 1]:group_limits[2, 2]]
d$y[group_limits[2, 1]:group_limits[2, 2]] %in% d_perm$y[group_limits[2, 1]:group_limits[2, 2]]
d$y[group_limits[2, 1]:group_limits[2, 2]] %in% d_perm$y[ord][group_limits[2, 1]:group_limits[2, 2]]
d$y[group_limits[2, 1]:group_limits[2, 2]] == d_perm$y[ord][group_limits[2, 1]:group_limits[2, 2]]
d$y[group_limits[2, 1]:group_limits[2, 2]] %in% d_perm$y[ord][group_limits[2, 1]:group_limits[2, 2]]
# Remove a possible intercept column from X and Z (in all cases -->
# die fügen wir immer von Hand dazu!)
if (length(unique(X[, 1])) == 1)  X <- X[, -1, drop = FALSE]
if (length(unique(Z[, 1])) == 1)  Z <- Z[, -1, drop = FALSE]
# Set the model dimensions
n <- nrow(X)
p <- ncol(X) + intercepts$fixed
k <- ncol(Z) + intercepts$random
intercepts = list(fixed = TRUE, random = TRUE)
adjust_re = TRUE
weighted = FALSE
use_outlyingness_weights = TRUE
leverage_columns = 1:ncol(X)
mean_function = "hodges_lehmann"
sd_function = "Qn_corrected"
control_mean_sd = list(
mean_function_arguments_fixed = list(),
mean_function_arguments_random = list(),
sd_function_arguments_fixed = list(),
sd_function_arguments_random = list())
# Welche Spalte von X korrespondiert zu welcher Spalte in Z? Sollen wir einfach
# vorschreiben dass die richtig sortiert sind?
# For now mal schon!
Z_matching <- as.logical(apply(Z, 2, function(z) sum(apply(X, 2, function(x) all(z == x)))))
X_matching <- as.logical(apply(X, 2, function(z) sum(apply(Z, 2, function(x) all(z == x)))))
if (intercepts$fixed & intercepts$random) X_matching <- c(TRUE, X_matching)
# Set the model dimensions
n <- nrow(X)
p <- ncol(X) + intercepts$fixed
k <- ncol(Z) + intercepts$random
# Fit the first regression
m <- ranklm(X = X, y = y, intercept = intercepts$fixed, weighted = weighted,
leverage_columns = leverage_columns,
mean_function = mean_function,
mean_function_arguments = mean_function_arguments_fixed)
# Assign the control parameters! (Hier wäre vielleicht eine control function
# cool, die alles was nicht übergeben wird auffüllt!)
list2env(control_mean_sd, envir = environment())
# Fit the first regression
m <- ranklm(X = X, y = y, intercept = intercepts$fixed, weighted = weighted,
leverage_columns = leverage_columns,
mean_function = mean_function,
mean_function_arguments = mean_function_arguments_fixed)
# Coefficients and predicted values
beta_hat <- m$coef
y_hat <- { if (intercepts$fixed) { cbind(1, X) } else { X } } %*% beta_hat
weights <- m$weights
# Calculate the residuals
marg_residuals <- y - y_hat
# Predict the random effects
groupwise_models <- lapply(1:n.groups, function(i) {
x = group_limits[i, ]
ranklm(y = marg_residuals[x[1]:x[2]],
X = Z[x[1]:x[2], , drop = FALSE],
intercept = intercepts$random,
weighted = weight_re, mcd=mcd,
mean_function = mean_function,
mean_function_arguments = mean_function_arguments_random)
})
weight_re=FALSE
# Predict the random effects
groupwise_models <- lapply(1:n.groups, function(i) {
x = group_limits[i, ]
ranklm(y = marg_residuals[x[1]:x[2]],
X = Z[x[1]:x[2], , drop = FALSE],
intercept = intercepts$random,
weighted = weight_re, mcd=mcd,
mean_function = mean_function,
mean_function_arguments = mean_function_arguments_random)
})
groupwise_models
tmp <- groupwise_models
detach(d_perm)
attach(d)
rm(g, n.groups, X, y, Z )
d
detach(d)
attach(d)
# Sort the variables by group:
ord <- order(g)
y <- y[ord, , drop = FALSE]
Z <- Z[ord, , drop = FALSE]
X <- X[ord, , drop = FALSE]
g_old <- g
g <- g[ord]
# Prepare group matching
n.groups <- length(unique(g))
group_sizes <- c(table(g))
group_limits <- cbind(cumsum(group_sizes) - group_sizes + 1, cumsum(group_sizes))
# Assign the control parameters! (Hier wäre vielleicht eine control function
# cool, die alles was nicht übergeben wird auffüllt!)
list2env(control_mean_sd, envir = environment())
# Remove a possible intercept column from X and Z (in all cases -->
# die fügen wir immer von Hand dazu!)
if (length(unique(X[, 1])) == 1)  X <- X[, -1, drop = FALSE]
if (length(unique(Z[, 1])) == 1)  Z <- Z[, -1, drop = FALSE]
# Welche Spalte von X korrespondiert zu welcher Spalte in Z? Sollen wir einfach
# vorschreiben dass die richtig sortiert sind?
# For now mal schon!
Z_matching <- as.logical(apply(Z, 2, function(z) sum(apply(X, 2, function(x) all(z == x)))))
X_matching <- as.logical(apply(X, 2, function(z) sum(apply(Z, 2, function(x) all(z == x)))))
if (intercepts$fixed & intercepts$random) X_matching <- c(TRUE, X_matching)
# Set the model dimensions
n <- nrow(X)
p <- ncol(X) + intercepts$fixed
k <- ncol(Z) + intercepts$random
# Fit the first regression
m <- ranklm(X = X, y = y, intercept = intercepts$fixed, weighted = weighted,
leverage_columns = leverage_columns,
mean_function = mean_function,
mean_function_arguments = mean_function_arguments_fixed)
# Coefficients and predicted values
beta_hat <- m$coef
y_hat <- { if (intercepts$fixed) { cbind(1, X) } else { X } } %*% beta_hat
weights <- m$weights
# Calculate the residuals
marg_residuals <- y - y_hat
# Predict the random effects
groupwise_models <- lapply(1:n.groups, function(i) {
x = group_limits[i, ]
ranklm(y = marg_residuals[x[1]:x[2]],
X = Z[x[1]:x[2], , drop = FALSE],
intercept = intercepts$random,
weighted = weight_re, mcd=mcd,
mean_function = mean_function,
mean_function_arguments = mean_function_arguments_random)
})
groupwise_models[[1]]
tmp[[1]]
tmp[[1]]$final_scores %in% groupwise_models[[1]]$fian
tmp[[1]]$final_scores %in% groupwise_models[[1]]$final_scores
b_hat <- matrix(unlist(lapply(groupwise_models, "[[", "coef")), n.groups, k, byrow = TRUE)
groupwise_leverage_weights <- lapply(groupwise_models, "[[", "weights")
# Calculate the residuals
cond_residuals <- c(unlist(apply(cbind(group_limits, b_hat), 1, function(x) {
if (intercepts$random) {
marg_residuals[x[1]:x[2]] - cbind(1, Z[x[1]:x[2], ]) %*% matrix(x[3:length(x)])
} else {
marg_residuals[x[1]:x[2]] - Z[x[1]:x[2], ] %*% matrix(x[3:length(x)])
}
})))
cond_residuals_new <- cond_residuals
tmp2
tmp
tmp[[1]]
tmp[[2]]
groupwise_models[[2]]
d$y[d$g == 2]
d_perm$y[d_perm$g == 2]
d_perm$y[d_perm$g == 2] %in% d$y[d$g == 2]
ranklm(d$X[d$g == 2], d$y[d$g == 2])
ranklm(d$X[d$g == 2, ], d$y[d$g == 2])
rep(1:3, 3)
install.packages("robustlmm")
install.packages("shiny")
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(shiny)
library(tidyverse)
library(magrittr)
library(rankLME)
library(lme4)
library(robustlmm)
library(robustbase)
source("C:/Users/bbrune/Documents/gitAS/ADVANCE/AP3/robustmems/setup.R")
install.packages("tinytex")
library(tinytex)
devtools::install("ranklme")
devtools::install()
help("plot.lm")
?ranklme
ggplot
x = r
r
x$diagnostics
ggplot2::ggplot2(
info,
aes(y, color=g)
) +
ggplot2::geom_line()
info = x$diagnostics
ggplot2::ggplot(
info,
aes(y, color=g)
) +
ggplot2::geom_line()
ggplot2::ggplot(
info,
aes(1:nrow(info), y, color=g)
) +
ggplot2::geom_line()
ggplot2::ggplot(
info,
aes(1:nrow(info), y, color=g)
) +
ggplot2::geom_point()
ggplot2::ggplot(
info,
aes(1:nrow(info), y, color=factor(g))
) +
ggplot2::geom_point()
ggplot2::ggplot(
info,
aes(1:nrow(info), y, color=factor(g))
) +
ggplot2::geom_point() +
theme(legend.position = "none")
if (which == 1) {
ggplot2::ggplot(
info,
aes(1:nrow(info), y, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
ggplot2::xlab("Index")
}
ggplot2::ggplot(
info,
aes(1:nrow(info), y, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
ggplot2::xlab("Index")
stopifnot(length(which) == 1)
which=1
stopifnot(length(which) == 1)
info = x$diagnostics
if (which == 1) {
ggplot2::ggplot(
info,
aes(1:nrow(info), y, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
ggplot2::xlab("Index")
} else if (which == 2) {
}
ggplot2::ggplot(
info,
aes(fitted_conditional, conditional_residuals, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none")
if (which == 1) {
ggplot2::ggplot(
info,
aes(1:nrow(info), y, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
ggplot2::xlab("Index")
} else if (which == 2) {
ggplot2::ggplot(
info,
aes(fitted_conditional, conditional_residuals, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
ggplot2::geom_hline(yintercept = 0, linetype="dotted")
}
which=2
if (which == 1) {
ggplot2::ggplot(
info,
aes(1:nrow(info), y, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
ggplot2::xlab("Index")
} else if (which == 2) {
ggplot2::ggplot(
info,
aes(fitted_conditional, conditional_residuals, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
ggplot2::geom_hline(yintercept = 0, linetype="dotted")
}
conditional_residuals
leverage
info %>% colnames
ggplot2::ggplot(
info,
aes(overall_leverage, conditional_residuals / x$sigma, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
ggplot2::geom_hline(yintercept = 0, linetype="dotted")
ggplot2::ggplot(
info,
aes(overall_leverage, conditional_residuals / x$sigma, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
geom_hline(yintercept = c(-2, 2)) +
geom_vline(xintercept = sqrt(qchisq(0.95, p)))
ggplot2::ggplot(
info,
aes(overall_leverage, conditional_residuals / x$sigma, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
geom_hline(yintercept = c(-2, 2)) +
geom_vline(xintercept = qchisq(0.95, p))
ggplot2::ggplot(
info,
aes(sqrt(overall_leverage), conditional_residuals / x$sigma, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
geom_hline(yintercept = c(-2, 2)) +
geom_vline(xintercept = sqrt(qchisq(0.95, p)))
x$beta
p = length(x$beta) - 1
ggplot2::ggplot(
info,
aes(sqrt(overall_leverage), conditional_residuals / x$sigma, color=(conditional_residuals / x$sigma) > 2 | overall_leverage > qchisq(0.95, p))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
geom_hline(yintercept = c(-2, 2)) +
geom_vline(xintercept = sqrt(qchisq(0.95, p)))
ggplot2::ggplot(
info,
aes(sqrt(overall_leverage), conditional_residuals / x$sigma, color=abs((conditional_residuals / x$sigma)) > 2 | overall_leverage > qchisq(0.95, p))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
geom_hline(yintercept = c(-2, 2)) +
geom_vline(xintercept = sqrt(qchisq(0.95, p)))
ggplot2::ggplot(
info,
aes(sqrt(overall_leverage), conditional_residuals / x$sigma, color=abs((conditional_residuals / x$sigma)) > 2 | overall_leverage > qchisq(0.95, p))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
geom_hline(yintercept = c(-2, 2)) +
geom_vline(xintercept = sqrt(qchisq(0.95, p))) +
xlab("Leverage") + ylab("Standardized conditional residual")
ggplot2::ggplot(
info,
aes(fitted_conditional, conditional_residuals, color=factor(g))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
ggplot2::geom_hline(yintercept = 0, linetype="dotted")
ggplot2::ggplot(
info,
aes(sqrt(overall_leverage), conditional_residuals / x$sigma, color=abs((conditional_residuals / x$sigma)) > 2 | overall_leverage > qchisq(0.95, p))
) +
ggplot2::geom_point() +
ggplot2::theme(legend.position = "none") +
geom_hline(yintercept = c(-2, 2)) +
geom_vline(xintercept = sqrt(qchisq(0.95, p))) +
xlab("Leverage") + ylab("Standardized conditional residuals")
