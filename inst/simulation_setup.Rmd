---
title: "Simulation setup and overview"
author: "Barbara Brune"
date: "2024-07-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=10, fig.height=10)
```

```{r}
library(rankLME)
library(robustlmm)
library(lme4)

library(ggplot2)
library(dplyr)
library(tidyr)

set.seed(1212)
```

```{r}
source("simulation_helpers.R")
```

# Introduction

In this document, we give a short introduction to the structure of the simulation studies reported in Brune, Ortner, Filzmoser (2024).

# Dataset generation

The function `raw_data()` creates a raw, uncontaminated dataset.

```{r}
d <- raw_data(
  n = 200, 
  p = 4, 
  k = 2, 
  n.groups = 20, 
  group_size = 10,
  ranef_distribution = "normal",
  error_distribution = "normal",
  sd_b = 0.5, 
  sd_eps = 1,
  sd_X = 2, 
  beta = rep(1, 4)
)
``` 

The data object is  alist of length 6, containing the design matrices `X`and `Z`, the response vector `y`, the random effects `b`, the group labels `g` and the number of groups `n.groups`.

```{r}
str(d)
```


Now the data can be contaminated with various types of outliers. We implemented contamination in the form of `y_outliers`, `leverage` and `breakdown`. `y_outliers()`and `leverage()` cause contamination with additive or multiplicative outliers, while `breakdown` replaces a certain proportion of the response values `y` by 1e6 to study the breakdown behavior.

```{r}
args(y_outliers)
args(leverage)
args(breakdown)
```

All three functions share the same arguments, precisely:

* `raw_data` -- the raw data generated by the `raw_data()` function
* `outlier_proportion`-- the proportion of outliers
* `outlier_level`-- groupwise contamination (`"groupwise"`) or single outliers within groups (`"single"`)
* `single_outlier_type` -- if `outlier_level == "single"`, the outlying observation can either be placed randomly (`"random"`) or sequentially (`"sequential"`)
* `x_outlier_type`-- either `mean` (additive outliers) or `variance`(multiplicative outliers)


```{r}
d_y_outliers = y_outliers(d, outlier_proportion=0.1, outlier_level="single", 
                          single_outlier_type="random", outlier_size=10, type="mean")

d_leverage = leverage(d, outlier_proportion=0.1, outlier_level="single", 
                          single_outlier_type="random", outlier_size=10, type="mean")

d_breakdown = breakdown(d, outlier_proportion=0.1, outlier_level="single", 
                          single_outlier_type="random", outlier_size=10, type="mean")
```


# Model fitting and comparison

The following function fits the four models that are part of the simulation study: 

* rank
* weighted_rank
* REML
* SMDM

The functions to produce simulation results can be found in the file `inst/simulation_helpers.R`.

We now fit the four models to the data:

```{r}
fitted_models_uncontaminated = compare_model_fits(d, with_smdm=TRUE)
fitted_models_leverage = compare_model_fits(d_leverage, with_smdm=TRUE)
fitted_models_breakdown = compare_model_fits(d_breakdown, with_smdm=TRUE)
fitted_models_y_outliers = compare_model_fits(d_y_outliers, with_smdm=TRUE)
```

The effects of the different contamination types on the estimates can e.g. be visualized in the following plot:

```{r}
res = do.call("rbind", lapply(
  list(fitted_models_uncontaminated, fitted_models_y_outliers, fitted_models_breakdown, fitted_models_leverage), get_coefficients_from_model
)) 

res$contamination = rep(c("none", "y_outliers", "breakdown", "leverage"), each = 7)
```

```{r}
res |>
  tidyr::pivot_longer(-c(contamination, coef)) |>
  ggplot(aes(coef, value, fill=name)) +
  geom_bar(stat="identity", position="dodge") +
  facet_wrap(contamination ~ ., scales="free_y") +
  scale_y_log10() +
  theme(axis.text.x = element_text(angle=45, hjust=1))

```


# Small-scale simulation run

The following code runs an exemplary simulation with multiplicative leverage outliers of different sizes. The number of replications within the for-loop can be adjusted for a larger scale simulation. The code may produce warnings since the standard REML method might run into numerical problems in the contaminated settings.

The results of the analysis can also be loaded from `inst/results_leverage.RData`.

```{r}
# set.seed(141414)
# sim_res = vector("list", length=length(seq(1, 20, 1)))
# run = 1
# 
# for (outl_size in seq(1, 20, 1)) {
#   sim_res[[run]] =  replicate(20, replicate_model_fits(outl_size, with_smdm=TRUE), simplify=FALSE)
#   run <- run + 1
# }
```
```{r}
# results = do.call("rbind", lapply(sim_res, function(x) do.call("rbind", x)))
# save(results, file="results_leverage.Rdata")
```

```{r}
load("../results_leverage_with_hat.RData")
```


```{r}
mses = results |>
  group_by(method, outlier_size) |>
  summarize(across(starts_with("beta"), ~ mean((.x - 1)^2)),
            across(starts_with("theta"), ~ mean((.x - 0.5)^2)),
            sigma = mean((`sigma^2` - 1)^2))

mses |>
  tidyr::pivot_longer(-c(method, outlier_size)) |>
  ggplot(aes(outlier_size, value, color=method)) +
  geom_line() + geom_point() +
  facet_wrap(name ~ ., scales="free") +
  theme_minimal() +
  ggtitle("MSE of estimated coefficients", 
          subtitle="Multiplicative leverage outliers")
```


```{r}
results |>
  tidyr::pivot_longer(-c(method, outlier_size)) |> 
  ggplot(aes(outlier_size, value, color=method, group=interaction(method, outlier_size))) +
  geom_boxplot() +
  facet_wrap(name ~ ., scales="free") +
  theme_minimal() +
  theme(legend.position="bottom") +
  ggtitle("Boxplots of estimated coefficients", 
          subtitle="Multiplicative leverage outliers")
  
```


