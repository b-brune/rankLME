---
title: "Simulation setup and overview"
author: "Barbara Brune"
date: "2024-07-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(rankLME)
library(robustlmm)
library(lme4)

set.seed(1212)
```

# Introduction

In this document, we give a short introduction to the structure of the simulation studies reported in Brune, Ortner, Filzmoser (2024).

# Dataset generation

The function `raw_data()` creates a raw, uncontaminated dataset.

```{r}
d <- raw_data(
  n = 200, 
  p = 4, 
  k = 2, 
  n.groups = 20, 
  group_size = 10,
  ranef_distribution = "normal",
  error_distribution = "normal",
  sd_b = 0.5, 
  sd_eps = 1,
  sd_X = 2, 
  beta = rep(1, 4)
)
``` 

The data object is  alist of length 6, containing the design matrices `X`and `Z`, the response vector `y`, the random effects `b`, the group labels `g` and the number of groups `n.groups`.

```{r}
str(d)
```


Now the data can be contaminated with various types of outliers. We implemented contamination in the form of `y_outliers`, `leverage` and `breakdown`. `y_outliers()`and `leverage()` cause contamination with additive or multiplicative outliers, while `breakdown` replaces a certain proportion of the response values `y` by 1e6 to study the breakdown behavior.

```{r}
args(y_outliers)
args(leverage)
args(breakdown)
```

All three functions share the same arguments, precisely:
#
* `raw_data` -- the raw data generated by the `raw_data()` function
* `outlier_proportion`-- the proportion of outliers
* `outlier_level`-- groupwise contamination (`"groupwise"`) or single outliers within groups (`"single"`)
* `single_outlier_type` -- if `outlier_level == "single"`, the outlying observation can either be placed randomly (`"random"`) or sequentially (`"sequential"`)
* `x_outlier_type`-- either `mean` (additive outliers) or `variance`(multiplicative outliers)

```{r}
d_y_outliers = y_outliers(d, outlier_proportion=0.1, outlier_level="single", 
                          single_outlier_type="random", outlier_size=10, type="mean")

d_leverage = leverage(d, outlier_proportion=0.1, outlier_level="single", 
                          single_outlier_type="random", outlier_size=10, type="mean")

d_breakdown = breakdown(d, outlier_proportion=0.1, outlier_level="single", 
                          single_outlier_type="random", outlier_size=10, type="mean")
```


# Model fitting and comparison

The following function fits the four models that are part of the simulation study: 

* rank
* weighted_rank
* REML
* SMDM


```{r}

compare_model_fits <- function(d) {
  require(lme4)
  require(robustlmm)
  require(rankLME)
  
  p <- ncol(d$X)
  k <- ncol(d$Z)
  n <- nrow(d$X)
  
  # Make a data matrix
  dat <- with(
    d,
    data.frame(
      magrittr::set_colnames(
        cbind(y, X, Z, g),
        c(
          "y", paste0("X", 1:p - 1),
          paste0("Z", 1:k - 1), "g"
        )
      )
    )
  )
  
  # Build formulas for the functions that need formulas:
  f1 <- paste("y", "~", paste(colnames(dat)[3:(p + 1)], collapse = " + "))
  f2 <- paste("(", "1 +", paste(colnames(dat)[(p + 3):(p + k + 1)], collapse = "+"), "|| g )", collapse = "")
  
  f <- formula(paste(f1, f2, sep = " + "))
  
  weighted_rank <- ranklme(
    X = d$X, y = d$y, Z = d$Z, g = d$g, 
    sd_function = "Qn_corrected",
    adjust_re =TRUE,
    control_mean_sd = list(
      mean_function_arguments_fixed = list(),
      mean_function_arguments_random = list(), 
      sd_function_arguments_fixed = list(p = (p + d$n.groups)),
      sd_function_arguments_random = list()),
    weighted = TRUE, 
    maxit = 20
  )
  
  rank <- ranklme(
    X = d$X, y = d$y, Z = d$Z, g = d$g,
    sd_function = "Qn_corrected", adjust_re =TRUE,
    control_mean_sd = list(
      mean_function_arguments_fixed = list(),
      mean_function_arguments_random = list(), 
      sd_function_arguments_fixed = list(p = (p + d$n.groups)),
      sd_function_arguments_random = list()),    weighted = FALSE,
    maxit = 20
  )
  
  lme <- lmer(f, data = dat)
  
  koller <- rlmer(f, data = dat)
  
  return(list(
    rank = rank, weighted_rank = weighted_rank, lme = lme, koller = koller
  ))
}
```

We now fit the four models to the data:

```{r}
fitted_models_uncontaminated = compare_model_fits(d)
fitted_models_leverage = compare_model_fits(d_leverage)
fitted_models_breakdown = compare_model_fits(d_breakdown)
fitted_models_y_outliers = compare_model_fits(d_y_outliers)
```

The effects of the different contamination types on the estimates are then visualized in the following plot:

```{r}
require(ggplot2)

get_coefficients_from_model <- function(fitted_object) {
  lme = with(fitted_object, 
             list(beta = fixef(lme),
                  variances = c(sigma(lme), 
                                unlist(lapply(VarCorr(lme), function(z) attr(z, "stddev")))))
  )
  smdm = with(fitted_object,
               list(beta = fixef(koller),
                  variances = c(sigma(koller), unlist(lapply(VarCorr(koller), function(z) attr(z, "stddev")))))
  )
  
  rank = with(fitted_object,
              list(beta = rank$beta,
                   variances = c(rank$sigma, rank$theta))
  )
  
  weighted_rank = with(fitted_object,
              list(beta = weighted_rank$beta,
                   variances = c(weighted_rank$sigma, weighted_rank$theta))
  )
  
  return(
    data.frame(
      REML = unlist(lme), 
      SMDM = unlist(smdm), 
      rank = unlist(rank), 
      weighted_rank = unlist(weighted_rank), 
      coef = c("beta_0", "beta_1", "beta_2", "beta_3", "error_variance", "randef_variance1", "randef_variance2"))  
  )
}
```

```{r}
res = do.call("rbind", lapply(
  list(fitted_models_uncontaminated, fitted_models_y_outliers, fitted_models_breakdown, fitted_models_leverage), get_coefficients_from_model
)) 

res$contamination = rep(c("none", "y_outliers", "breakdown", "leverage"), each = 7)
```

```{r}
res |>
  tidyr::pivot_longer(-c(contamination, coef)) |>
  ggplot(aes(coef, value, fill=name)) +
  geom_bar(stat="identity", position="dodge") +
  facet_wrap(contamination ~ ., scales="free_y") +
  scale_y_log10() +
  theme(axis.text.x = element_text(angle=45, hjust=1))

```

